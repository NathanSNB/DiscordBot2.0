import discord
from discord.ext import commands, tasks
import json
import os
import random
import logging
from dotenv import load_dotenv
from zoneinfo import ZoneInfo
import pytz
from datetime import datetime, timedelta

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger("BedtimeReminder")

# Chargement des variables d'environnement
load_dotenv()

# Constantes
CONFIG_FILE = 'data/reminders.json'
USER_PREFERENCES_FILE = 'data/user_preferences.json'
DEFAULT_REMINDER_TIME = "22:00"
EMBED_COLOR = 0x2BA3B3
FOOTER_TEXT = "Syst√®me de Rappels ÔΩú ¬© 2025"
TIMEZONE = "Europe/Paris"

# Styles d'embeds pour les rappels
REMINDER_STYLES = [
    {
        "title": "üåô Il est temps de se reposer",
        "color": 0x7B68EE,  # Violet moyen
        "image": "https://i.imgur.com/2DrXEHX.png",  # Image de nuit √©toil√©e
        "emoji": "üå†"
    },
    {
        "title": "üò¥ L'heure du sommeil a sonn√©",
        "color": 0x483D8B,  # Bleu ardoise fonc√©
        "image": "https://i.imgur.com/qL31YcD.png",  # Image de lune
        "emoji": "üåú"
    },
    {
        "title": "üí§ Un rappel pour bien dormir",
        "color": 0x4682B4,  # Bleu acier
        "image": "https://i.imgur.com/E4LJ8EY.png",  # Image zen
        "emoji": "‚ú®"
    },
    {
        "title": "üõå Votre rappel nocturne",
        "color": 0x2E8B57,  # Vert marin
        "image": "https://i.imgur.com/H8FZHEC.png",  # Image relaxante
        "emoji": "üåø"
    }
]

# Citations pour les rappels
REMINDER_QUOTES = [
    "Un bon sommeil est la cl√© d'une journ√©e productive.",
    "Dormir suffisamment am√©liore votre m√©moire et concentration.",
    "Reposez votre esprit pour mieux affronter demain.",
    "Le sommeil est le meilleur m√©dicament.",
    "Une bonne nuit de sommeil r√©pare le corps et l'esprit."
]

class BedtimeReminder(commands.Cog):
    """Syst√®me de rappels personnalis√©s pour les utilisateurs Discord"""

    def __init__(self, bot):
        self.bot = bot
        self.timezone = pytz.timezone(TIMEZONE)
        self.messages = self._load_messages()
        self.user_preferences = self._load_user_preferences()
        self.reminder_check.start()
        logger.info("‚úÖ Module de rappels personnalis√©s initialis√©")

    def _load_messages(self):
        """Charge les messages de rappel depuis le fichier JSON"""
        try:
            if os.path.exists(CONFIG_FILE):
                with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    logger.info(f"üìÇ Messages charg√©s: {len(config.get('messages', []))}")
                    return config.get('messages', [])
            else:
                default_messages = [
                    "Il est temps de se d√©tendre et de se pr√©parer pour la nuit.",
                    "N'oubliez pas de vous reposer pour √™tre en forme demain.",
                    "Accordez-vous du temps pour un sommeil r√©parateur.",
                    "Pensez √† mettre votre t√©l√©phone en mode silencieux pour une meilleure qualit√© de sommeil."
                ]
                os.makedirs(os.path.dirname(CONFIG_FILE), exist_ok=True)
                with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                    json.dump({"messages": default_messages}, f, indent=4)
                logger.info("üìù Fichier de messages par d√©faut cr√©√©")
                return default_messages
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du chargement des messages: {str(e)}")
            return []

    def _save_messages(self, messages):
        """Sauvegarde les messages dans le fichier JSON"""
        try:
            with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                json.dump({"messages": messages}, f, indent=4)
            self.messages = messages
            logger.info("üíæ Messages sauvegard√©s")
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la sauvegarde des messages: {str(e)}")

    def _load_user_preferences(self):
        """Charge les pr√©f√©rences utilisateur depuis le fichier JSON"""
        try:
            if os.path.exists(USER_PREFERENCES_FILE):
                with open(USER_PREFERENCES_FILE, 'r', encoding='utf-8') as f:
                    preferences = json.load(f)
                    logger.info(f"üìÇ Pr√©f√©rences charg√©es: {len(preferences)} utilisateurs")
                    return preferences
            else:
                os.makedirs(os.path.dirname(USER_PREFERENCES_FILE), exist_ok=True)
                with open(USER_PREFERENCES_FILE, 'w', encoding='utf-8') as f:
                    json.dump({}, f, indent=4)
                logger.info("üìù Fichier de pr√©f√©rences utilisateur cr√©√©")
                return {}
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du chargement des pr√©f√©rences: {str(e)}")
            return {}

    def _save_user_preferences(self):
        """Sauvegarde les pr√©f√©rences utilisateur dans le fichier JSON"""
        try:
            with open(USER_PREFERENCES_FILE, 'w', encoding='utf-8') as f:
                json.dump(self.user_preferences, f, indent=4)
            logger.info("üíæ Pr√©f√©rences utilisateur sauvegard√©es")
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la sauvegarde des pr√©f√©rences: {str(e)}")

    def create_reminder_embed(self, message):
        """
        Cr√©e un embed Discord attrayant pour un rappel
        
        Args:
            message (str): Message principal du rappel
            
        Returns:
            discord.Embed: L'embed format√©
        """
        # S√©lectionner un style al√©atoire
        style = random.choice(REMINDER_STYLES)
        
        # Ajouter une citation
        quote = random.choice(REMINDER_QUOTES)
        
        # Obtenir l'heure actuelle dans le fuseau horaire configur√©
        now = datetime.now(ZoneInfo(TIMEZONE))
        current_time = f"{now.hour:02d}:{now.minute:02d}"
        
        # Cr√©er l'embed
        embed = discord.Embed(
            title=style["title"],
            description=f"**{style['emoji']} {message}**\n\n> *\"{quote}\"*",
            color=discord.Color(style["color"]),
            timestamp=datetime.now()
        )
        
        # Ajouter l'image si disponible
        if style.get("image"):
            embed.set_thumbnail(url=style["image"])
        
        # Ajouter la date et l'heure
        embed.add_field(
            name="‚è∞ Heure locale",
            value=f"{current_time}",
            inline=True
        )
        
        embed.add_field(
            name="üìÖ Date",
            value=f"{now.strftime('%d/%m/%Y')}",
            inline=True
        )
        
        # Ajouter un conseil al√©atoire pour le sommeil
        sleep_tips = [
            "√âvitez les √©crans 1h avant de dormir",
            "Gardez votre chambre fra√Æche et sombre",
            "Une routine r√©guli√®re am√©liore la qualit√© du sommeil",
            "Limitez la caf√©ine en fin de journ√©e",
            "La m√©ditation peut vous aider √† mieux dormir"
        ]
        
        embed.add_field(
            name="üí° Conseil du jour",
            value=random.choice(sleep_tips),
            inline=False
        )
        
        embed.set_footer(text=f"{FOOTER_TEXT} ‚Ä¢ Passez une douce nuit")
        return embed

    def create_embed(self, title, description=None, fields=None, color=None):
        """
        Cr√©e un embed Discord standard pour les r√©ponses de commandes
        
        Args:
            title (str): Titre de l'embed
            description (str, optional): Description de l'embed
            fields (list, optional): Liste de tuples (name, value, inline) pour les champs
            color (int, optional): Couleur personnalis√©e de l'embed
            
        Returns:
            discord.Embed: L'embed format√©
        """
        embed = discord.Embed(
            title=title,
            description=description,
            color=discord.Color(color if color else EMBED_COLOR),
            timestamp=datetime.now()
        )
        
        if fields:
            for name, value, inline in fields:
                embed.add_field(name=name, value=value, inline=inline)
                
        embed.set_footer(text=FOOTER_TEXT)
        return embed

    @tasks.loop(minutes=1)
    async def reminder_check(self):
        """V√©rifie si c'est l'heure d'envoyer les rappels et les envoie si n√©cessaire"""
        try:
            # Obtenir l'heure actuelle dans le fuseau horaire configur√©
            now = datetime.now(ZoneInfo(TIMEZONE))
            current_time = f"{now.hour:02d}:{now.minute:02d}"
            
            if not self.messages:
                return
                
            # V√©rifier pour chaque utilisateur si c'est l'heure de son rappel
            users_notified = 0
            
            for user_id, prefs in self.user_preferences.items():
                if not prefs.get("active", False):
                    continue
                    
                if current_time != prefs.get("time", DEFAULT_REMINDER_TIME):
                    continue
                
                # Choisir un message pour l'utilisateur
                message = random.choice(self.messages)
                
                # Cr√©er l'embed personnalis√©
                embed = self.create_reminder_embed(message)
                
                # Envoyer le rappel
                try:
                    user = await self.bot.fetch_user(int(user_id))
                    await user.send(embed=embed)
                    users_notified += 1
                    logger.info(f"üì® Rappel envoy√© √† {user.name} ({user_id})")
                except Exception as e:
                    logger.error(f"‚ùå Impossible d'envoyer le rappel √† l'utilisateur {user_id}: {str(e)}")
            
            if users_notified > 0:
                logger.info(f"üì® Rappels envoy√©s √† {users_notified} utilisateurs")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la v√©rification des rappels: {str(e)}")

    @reminder_check.before_loop
    async def before_reminder_check(self):
        """Attendre que le bot soit pr√™t avant de commencer la boucle de v√©rification"""
        await self.bot.wait_until_ready()
        logger.info("üîÑ D√©marrage de la boucle de v√©rification des rappels")

    @commands.command(name="rappel_activer", aliases=["reminder_on", "activate_reminder"])
    async def activate_reminder(self, ctx):
        """Active les rappels pour l'utilisateur"""
        user_id = str(ctx.author.id)
        
        if user_id not in self.user_preferences:
            self.user_preferences[user_id] = {
                "active": True,
                "time": DEFAULT_REMINDER_TIME,
                "name": ctx.author.name
            }
        else:
            self.user_preferences[user_id]["active"] = True
            
        self._save_user_preferences()
        
        user_time = self.user_preferences[user_id]["time"]
        
        embed = self.create_embed(
            "‚úÖ Rappels Activ√©s",
            f"Vous recevrez d√©sormais des rappels quotidiens √† **{user_time}**.\n\nUtilisez `!rappel_heure HH:MM` pour modifier l'heure de rappel."
        )
        await ctx.send(embed=embed)

    @commands.command(name="rappel_desactiver", aliases=["reminder_off", "deactivate_reminder"])
    async def deactivate_reminder(self, ctx):
        """D√©sactive les rappels pour l'utilisateur"""
        user_id = str(ctx.author.id)
        
        if user_id not in self.user_preferences:
            self.user_preferences[user_id] = {
                "active": False,
                "time": DEFAULT_REMINDER_TIME,
                "name": ctx.author.name
            }
        else:
            self.user_preferences[user_id]["active"] = False
            
        self._save_user_preferences()
        
        embed = self.create_embed(
            "üîï Rappels D√©sactiv√©s",
            "Vous ne recevrez plus de rappels quotidiens.\n\nUtilisez `!rappel_activer` pour les r√©activer."
        )
        await ctx.send(embed=embed)

    @commands.command(name="rappel_heure", aliases=["reminder_time", "set_reminder_time"])
    async def set_reminder_time(self, ctx, new_time: str):
        """Modifie l'heure √† laquelle l'utilisateur re√ßoit les rappels"""
        user_id = str(ctx.author.id)
        
        # V√©rifier le format de l'heure
        try:
            hour, minute = map(int, new_time.split(':'))
            
            if not (0 <= hour <= 23 and 0 <= minute <= 59):
                raise ValueError("Heure invalide")
                
            formatted_time = f"{hour:02d}:{minute:02d}"
            
            # Mettre √† jour les pr√©f√©rences utilisateur
            if user_id not in self.user_preferences:
                self.user_preferences[user_id] = {
                    "active": True,
                    "time": formatted_time,
                    "name": ctx.author.name
                }
            else:
                self.user_preferences[user_id]["time"] = formatted_time
                if "active" not in self.user_preferences[user_id]:
                    self.user_preferences[user_id]["active"] = True
                    
            self._save_user_preferences()
            
            # Calculer le temps restant avant le prochain rappel
            now = datetime.now(ZoneInfo(TIMEZONE))
            reminder_time = datetime.strptime(formatted_time, "%H:%M").time()
            
            if now.time() > reminder_time:
                # Le rappel est pour demain
                next_reminder = datetime.combine(now.date() + timedelta(days=1), reminder_time)
            else:
                # Le rappel est pour aujourd'hui
                next_reminder = datetime.combine(now.date(), reminder_time)
                
            next_reminder = pytz.timezone(TIMEZONE).localize(next_reminder)
            time_delta = next_reminder - now
            hours, remainder = divmod(time_delta.seconds, 3600)
            minutes, _ = divmod(remainder, 60)
            
            # Confirmer la modification
            embed = self.create_embed(
                "‚è∞ Heure de Rappel Modifi√©e",
                f"Vos rappels seront d√©sormais envoy√©s √† **{formatted_time}**.\n\n"
                f"Prochain rappel dans: **{hours}h {minutes}m**"
            )
            
            status = "activ√©s" if self.user_preferences[user_id]["active"] else "d√©sactiv√©s"
            embed.add_field(
                name="√âtat des rappels",
                value=f"Vos rappels sont actuellement **{status}**.",
                inline=False
            )
            
            await ctx.send(embed=embed)
            
        except ValueError:
            await ctx.send(embed=self.create_embed(
                "‚ùå Erreur",
                "Format d'heure invalide. Utilisez le format `HH:MM` (ex: 22:00)."
            ))

    @commands.command(name="rappel_test", aliases=["test_reminder"])
    async def test_reminder(self, ctx):
        """Envoie un rappel de test √† l'utilisateur"""
        if not self.messages:
            await ctx.send(embed=self.create_embed(
                "‚ùå Erreur",
                "Aucun message configur√© pour le test."
            ))
            return
            
        # S√©lectionner un message al√©atoire
        message = random.choice(self.messages)
        
        # Cr√©er l'embed pour le rappel de test
        test_embed = self.create_reminder_embed(message)
        test_embed.description = f"{test_embed.description}\n\n*Ceci est un rappel de test.*"
        
        # Envoyer le rappel de test
        try:
            await ctx.author.send(embed=test_embed)
            await ctx.send(embed=self.create_embed(
                "‚úÖ Test R√©ussi",
                "Un rappel de test vous a √©t√© envoy√© par message priv√©."
            ))
        except Exception as e:
            await ctx.send(embed=self.create_embed(
                "‚ùå Erreur",
                f"Impossible de vous envoyer un message priv√©: {str(e)}\n\n"
                "V√©rifiez que vous avez activ√© la r√©ception des messages priv√©s sur ce serveur."
            ))

    @commands.command(name="rappel_statut", aliases=["reminder_status", "reminder_info"])
    async def reminder_status(self, ctx):
        """Affiche le statut des rappels pour l'utilisateur"""
        user_id = str(ctx.author.id)
        
        if user_id not in self.user_preferences:
            await ctx.send(embed=self.create_embed(
                "‚ÑπÔ∏è Statut des Rappels",
                "Vous n'avez pas encore configur√© de rappels.\n\n"
                "Utilisez `!rappel_activer` pour commencer √† recevoir des rappels."
            ))
            return
            
        prefs = self.user_preferences[user_id]
        status = "activ√©s" if prefs.get("active", False) else "d√©sactiv√©s"
        
        # Calculer le temps restant avant le prochain rappel
        now = datetime.now(ZoneInfo(TIMEZONE))
        reminder_time = datetime.strptime(prefs.get("time", DEFAULT_REMINDER_TIME), "%H:%M").time()
        
        if now.time() > reminder_time or not prefs.get("active", False):
            # Le rappel est pour demain ou les rappels sont d√©sactiv√©s
            next_reminder = datetime.combine(now.date() + timedelta(days=1), reminder_time)
        else:
            # Le rappel est pour aujourd'hui
            next_reminder = datetime.combine(now.date(), reminder_time)
            
        next_reminder = pytz.timezone(TIMEZONE).localize(next_reminder)
        time_delta = next_reminder - now
        hours, remainder = divmod(time_delta.seconds, 3600)
        minutes, _ = divmod(remainder, 60)
        
        embed = self.create_embed(
            "üìä Statut de vos Rappels",
            f"**√âtat:** {status}\n"
            f"**Heure configur√©e:** {prefs.get('time', DEFAULT_REMINDER_TIME)}\n"
            f"**Fuseau horaire:** {TIMEZONE}\n\n"
            f"**Heure actuelle:** {now.strftime('%H:%M')}\n"
            f"**Prochain rappel:** {hours}h {minutes}m" if prefs.get("active", False) else "Rappels d√©sactiv√©s"
        )
        
        embed.add_field(
            name="üí° Commandes utiles",
            value="- `!rappel_test` pour recevoir un rappel de test\n"
                 f"- `!rappel_{'desactiver' if prefs.get('active', False) else 'activer'}` pour {('d√©sactiver' if prefs.get('active', False) else 'activer')} les rappels\n"
                 "- `!rappel_heure HH:MM` pour changer l'heure",
            inline=False
        )
        
        await ctx.send(embed=embed)

    @commands.command(name="rappel_ajouter", aliases=["add_reminder_message"])
    @commands.has_permissions(administrator=True)
    async def add_reminder_message(self, ctx, *, message: str):
        """Ajoute un message √† la liste des rappels"""
        # V√©rifier si le message existe d√©j√†
        if message in self.messages:
            await ctx.send(embed=self.create_embed(
                "‚ùå Erreur",
                "Ce message existe d√©j√† dans la liste."
            ))
            return
            
        self.messages.append(message)
        self._save_messages(self.messages)
        
        await ctx.send(embed=self.create_embed(
            "‚úÖ Message Ajout√©",
            f"**Message ajout√© √† la liste des rappels:**\n{message}"
        ))

    @commands.command(name="rappel_messages", aliases=["list_reminder_messages"])
    @commands.has_permissions(administrator=True)
    async def list_reminder_messages(self, ctx):
        """Affiche tous les messages de rappel configur√©s"""
        if not self.messages:
            await ctx.send(embed=self.create_embed(
                "üìù Messages de Rappel",
                "Aucun message configur√©. Utilisez `!rappel_ajouter` pour en ajouter."
            ))
            return

        # Cr√©er des pages si n√©cessaire pour les grands ensembles de messages
        messages_per_page = 5
        pages = [self.messages[i:i+messages_per_page] for i in range(0, len(self.messages), messages_per_page)]
        
        for i, page in enumerate(pages):
            embed = self.create_embed(
                f"üìù Messages de Rappel (Page {i+1}/{len(pages)})",
                f"**{len(self.messages)}** messages disponibles"
            )
            
            for j, msg in enumerate(page):
                index = i * messages_per_page + j + 1
                embed.add_field(
                    name=f"Message #{index}",
                    value=msg,
                    inline=False
                )
                
            await ctx.send(embed=embed)

    @commands.command(name="rappel_supprimer", aliases=["delete_reminder_message"])
    @commands.has_permissions(administrator=True)
    async def delete_reminder_message(self, ctx, index: int):
        """Supprime un message de la liste des rappels"""
        if not self.messages:
            await ctx.send(embed=self.create_embed(
                "‚ùå Erreur",
                "Aucun message configur√© √† supprimer."
            ))
            return
            
        try:
            # Ajuster l'index pour correspondre √† l'affichage (commen√ßant √† 1)
            adj_index = index - 1
            
            if adj_index < 0 or adj_index >= len(self.messages):
                raise IndexError()
                
            removed_message = self.messages.pop(adj_index)
            self._save_messages(self.messages)
            
            await ctx.send(embed=self.create_embed(
                "‚úÖ Message Supprim√©",
                f"**Message #{index} supprim√©:**\n{removed_message}"
            ))
            
        except IndexError:
            await ctx.send(embed=self.create_embed(
                "‚ùå Erreur",
                f"Index invalide. Utilisez un nombre entre 1 et {len(self.messages)}."
            ))

    @commands.command(name="rappel_utilisateurs", aliases=["list_reminder_users"])
    @commands.has_permissions(administrator=True)
    async def list_reminder_users(self, ctx):
        """Affiche tous les utilisateurs configur√©s pour recevoir des rappels"""
        if not self.user_preferences:
            await ctx.send(embed=self.create_embed(
                "üë• Utilisateurs Configur√©s",
                "Aucun utilisateur n'a encore configur√© de rappels."
            ))
            return

        active_users = [uid for uid, prefs in self.user_preferences.items() if prefs.get("active", False)]
        
        embed = self.create_embed(
            "üë• Utilisateurs Configur√©s",
            f"**{len(active_users)}/{len(self.user_preferences)}** utilisateurs ont activ√© les rappels"
        )
        
        # Ajouter des informations sur les utilisateurs actifs
        if active_users:
            active_field = ""
            for user_id in active_users:
                prefs = self.user_preferences[user_id]
                try:
                    user = await self.bot.fetch_user(int(user_id))
                    active_field += f"‚Ä¢ {user.mention} - {prefs.get('time', DEFAULT_REMINDER_TIME)}\n"
                except:
                    active_field += f"‚Ä¢ Utilisateur {prefs.get('name', 'inconnu')} (ID: {user_id}) - {prefs.get('time', DEFAULT_REMINDER_TIME)}\n"
            
            embed.add_field(
                name="‚úÖ Utilisateurs avec rappels activ√©s",
                value=active_field if active_field else "Aucun",
                inline=False
            )
        
        # Ajouter des informations sur les utilisateurs inactifs
        inactive_users = [uid for uid, prefs in self.user_preferences.items() if not prefs.get("active", False)]
        if inactive_users:
            inactive_field = ""
            for user_id in inactive_users:
                prefs = self.user_preferences[user_id]
                try:
                    user = await self.bot.fetch_user(int(user_id))
                    inactive_field += f"‚Ä¢ {user.mention} - {prefs.get('time', DEFAULT_REMINDER_TIME)}\n"
                except:
                    inactive_field += f"‚Ä¢ Utilisateur {prefs.get('name', 'inconnu')} (ID: {user_id}) - {prefs.get('time', DEFAULT_REMINDER_TIME)}\n"
            
            embed.add_field(
                name="üîï Utilisateurs avec rappels d√©sactiv√©s",
                value=inactive_field if inactive_field else "Aucun",
                inline=False
            )
                
        await ctx.send(embed=embed)

async def setup(bot):
    """Fonction d'initialisation du module pour Discord.py"""
    await bot.add_cog(BedtimeReminder(bot))
    logger.info("‚úÖ Module BedtimeReminder personnalis√© charg√© avec succ√®s")